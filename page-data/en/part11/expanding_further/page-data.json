{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part11/expanding_further","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>This module has focused on building a simple, effective and robust CI system that helps developers to work together, maintain code quality and deploy safely. What more could one possibly want? In the real world, there are more fingers in the pie than just developers and users. Even if that weren't true, even for developers, there's a lot more value to be gained from CI systems than just the above things.</p>\n<h3>Visibility and Understanding</h3>\n<p>In all but the smallest companies, decisions on what to develop are not made exclusively by developers. The term 'stakeholder' is often used to refer to people (both inside and outside the development team) who may have some interest in keeping an eye on the progress of development. To this end, there are often integrations between git and whatever project management/bug tracking software the team is using.</p>\n<p>A common use of this is to have some reference to the tracking system in git PRs or commits. This way, for example, when you're working on issue number 123, you might name your PR <code class=\"language-text\">BUG-123: Fix user copy issue</code> and the bug tracking system would notice the first part of the PR name and automatically move the issue to <code class=\"language-text\">Done</code> when the PR is merged.</p>\n<h3>Notifications</h3>\n<p>When the CI process finishes quickly, it can be convenient to just watch it execute and wait for the result. As projects become more complex, so too does the process of building and testing the code. This can quickly lead to a situation where it takes long enough to generate the build result that a developer may want to begin working on another task. This in turn leads to forgotten build. This is especially problematic if we're talking about merging PRs that may affect another developer's work, either causing problems or delays for them. This can also lead to a situation where you think you've deployed something but haven't actually finished a deployment, this can lead to mis-communication with team mates and customers (e.g. \"Go ahead and try that again, the bug should be fixed\").</p>\n<p>There are several solutions to this problem ranging from simple notifications to more complicated processes that simply merge passing code if certain conditions are met. We're going to discuss notifications as a simple solution since it's the one that interferes with the team workflow the least.</p>\n<p>By default, GitHub Actions sends an email on a build failure. This can be changed to send notifications regardless of build status and can also be configured to alert you on the GitHub web interface. Great. But what if we want more. What if for whatever reason this doesn't work for our use case.</p>\n<p>There are integrations, for example with Slack, to send notifications. These integrations still decide what to send and when to send it based on logic from GitHub.</p>\n<p>Let's go one step further. Let's set up our own notification system:</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 11.19</h3>\n<h4>11.19 Build success/failure notification action</h4>\n<p>Using the build from the previous section, set up a notification to either:\n1: Tell us that the build succeeded and the project is ready for deployment\n2: There was a problem that needs to be fixed. In this case, make it as easier for the developer to work out what went wrong. Send either the test report with the failing tests or a link to where said report can be found.</p>\n<p>You can choose the channel that the notification will be sent to but you will need to explain why you chose the channel that you chose.</p>\n<p>When doing this excercise, remember the following things.</p>\n<ul>\n<li>The notifications should <em>always</em> be sent, even if the build fails in a much earlier step. Is there any failure that would prevent a notification from being sent?</li>\n<li>The status of jobs in the build needs to be sent too, how do you get that? How do you present it?</li>\n</ul>\n </div>\n <div class=\"content\">\n<h3>Metrics</h3>\n<p>In the previous section we mentioned that as projects get more complicated, so too, do their builds and the duration that the builds take increases. That's obviously not ideal: The longer the feedback loop, the slower the development.</p>\n<p>While there are things that can be done about this increase in build times, it's useful to have a better view of the picture. It's useful to know how long a build took a few months ago versus how long it takes now. Was the progression linear or did it suddenly jump? Knowing what caused the increase in build time can be very useful in helping to solve it. If the build time increased linearly from 5 minutes to 10 over the last year, maybe we can expect it to take another few months to get to 15 minutes and we have an idea of how much value there is in spending time speeding up the CI process.</p>\n<p>Metrics can either be self-reported (also called 'push' metrics, where each build reports how long it took) or the data can be fetched from the API afterwards (sometimes called 'pull' metrics). The risk with self reporting is that the self reporting itself takes time and may have a significant impact on \"total time taken for all builds\".</p>\n<p>This data can be sent to a time series database or to an archive of another type.</p>\n<h3>Periodic tasks</h3>\n<p>There are often periodic tasks that need to be done in a software development team. Some of these can be automated with commonly available tools and some you will need to automate yourself.</p>\n<p>The former category includes things like checking packages for security vulnerabilities. There are several tools that can already do this for you. Some of these tools would even be free for certain types (e.g. open source) projects. Github provides one such tool, Dependabot.</p>\n<p>Words of advice to consider: If your budget allows it, it's almost always better to use a tool that already does the job than to roll your own solution. If security isn't the industry you're aiming for, for example, use Dependabot to check for security vulnerabilities instead of making your own tool.</p>\n<p>What about the tasks that don't have a tool? You can automate these yourself with GitHub Actions too. GitHub Actions provides a scheduled trigger that can be used to execute a task at a particular time.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 11.20-22</h3>\n<h4>11.20</h4>\n<p>Periodic ping</p>\n<h4>11.13 Average runtime notification action</h4>\n<p>Let's combine the the past last 3 sections together: Write an action that will send the average run time for all <code class=\"language-text\">build</code>, <code class=\"language-text\">lint</code>, <code class=\"language-text\">test</code> and <code class=\"language-text\">deploy</code> actions in the repo the workflow is situated in to an email address for archiving. You will likely need to create an action that calls the GitHub API for this.</p>\n<p>Hint: Github provides a JS and a TS starter action for you to base your action on. These already import the relevant libraries and have some examples of how to use them.</p>\n<p>SKIP or REDFINE</p>\n<h4>11.21 Your own pipeline</h4>\n<p>Build a simillar CI/CD-pipeline for some of your own products. A good candidate is the phonebook app that was built in parts 2 to 4 of the course, or bloglist built in part 5, or the redux anecdotes built in part 6. You may also use some app of your own here.</p>\n<p>You most likely need to do some restructuring to get all the pieces togeteher. A logical first step would be to store both the frontend and backend code in a same repository. This is not a requirement but it is recommended since it makes things much more simple.</p>\n<p>One possible repository structure would be to have backend at the root of repository and the fronend as a subdirectory. You can also \"copy paste\" the structure of the example app of this chapter or try out the <a href=\"https://github.com/fullstack-hy2020/create-app\">example app</a> mentioned in <a href=\"/en/part7/class_components_miscellaneous#frontend-and-backend-in-the-same-repository\">part 7</a>.</p>\n<p>It is perhaps best to create a new repository for this exercise and simply copy and paste the old code. In real life you most likely would to this all in the old repository but now \"a fresh start\" makes things easier.</p>\n<p>This is a long and perhaps quite a tought exercise, but this kind of situation where you have a \"legacy code\" and you need to build it a proper deployment pipeline is quite commoin in real life!</p>\n<h4>11.22 Protect master and ask for pr</h4>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/83f1c8a7795e9e8eaffaec29b1ee79b1/part-1.svg"},"part":11,"letter":"e","lang":"en"}}},"pageContext":{"part":11,"letter":"e","lang":"en"}}}